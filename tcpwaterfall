#!/usr/bin/perl

# Diagram timescale in ms (= 1 char on screen)
my $timescale_ms = 50;

# Time scale spacing (characters)
my $scaleint = 10;

my $tcpdump_cmd = "tcpdump -tt -s 500 -l -i any";

##############################################################
# cmdline args

sub usage
{
    print "Usage: tcpwaterfall [options] < capture_file | less -SR\n";
    print "\n";
    print "  Display a waterfall diagram of tcp connections from tcpdump output.\n";
    print "  Open in your favorite editor, or less to makes it 4 way scrollable\n";
    print "  (use arrows to navigate the waterfall!)\n";
    print "\n";
    print "  Generate capture file with something like:\n";
    print "    $tcpdump_cmd > capture_file          (-tt is important)\n";
    print "  To use wireshark capture, save in \"wireshark/tcpdump/libpcap\" format, and\n";
    print "    tcpdump -tt -s 500 -l -r wireshark_capture.pcap > capture_file\n";
    print "  (use -n if you don't want name resolution)\n";
    print "\n";
    print "  Diagram scale:\n";
    print "    -t timescale  Set diagram's time scale in ms  [default $timescale_ms]\n";
    print "                  (1 char on screen = timescale ms)\n";
    print "    -w            Fit to term's width.\n";
    print "    -c cols       Number of columns to display output.\n";
    print "\n";
    print "  Display etc:\n";
    print "    -l            Show hostname for localhost instead of port only.\n";
    print "    -z            Show packets without data (acks...)  (default: hidden)\n";
    print "    -r            Raw output, don't use colors.\n";
    print "    -d            Debug mode. Show packets ignored by the parser.\n";
    print "\n";
    print "  Stream display  [: SYN flag\n";
    print "      format:     ]: FIN flag\n";
    print "                  O: SYN then FIN\n";
    print "                  I: FIN then SYN\n";
    print "                  #: packet with data\n";
    print "                  _: packet without data (ack...)\n";
    print "                  .: silence\n";
    exit(1);
}

for (; @ARGV != 0; shift(@ARGV))
{
   if ($ARGV[0] eq "-t")
   {
       shift(@ARGV);       
       $timescale_ms = $ARGV[0];
       next;
   }
   if ($ARGV[0] eq "-r")
   {
       $no_colors=1;
       next;
   }
   if ($ARGV[0] eq "-d")
   {
       $debug_mode=1;
       next;
   }
   if ($ARGV[0] eq "-w")
   {
       $columns = `tput cols`;
       next;
   }
   if ($ARGV[0] eq "-c")
   {
       shift(@ARGV);       
       $columns = $ARGV[0];
       next;
   }
   if ($ARGV[0] eq "-l")
   {
       $show_localhost_src = 1;
       next;
   }
   if ($ARGV[0] eq "-z")
   {
       $show_empty = 1;
       next;
   }

   usage();
}

##############################################################
# processing

my $mintime = -1;
my $maxtime = 0;
my @packets;
# Formatting: longest src
my $max_src = 0;

# tcpdump output parsing
foreach my $str (<STDIN>)
{
    if ($str =~ m|(.*) IP (.*)\.([^.]*) > (.*)\.([^.]*): Flags \[(.*)\],.*, length (.*)|)
    {
	my @tab = ($1, $2, $3, $4, $5, $6, $7);
	my ($timestamp, $src, $sport, $dst, $dport, $flags, $len) = @tab;
#	print ".";

	$mintime = $timestamp if ($mintime eq -1);
	$maxtime = $timestamp;
	$max_src = length($src) if (length($src) > $max_src);

	push(@packets, \@tab);
	next;
    }
    print $str if ($debug_mode);
}
#print "\n";
exit(0) if ($debug_mode);

# Stream handling
my %streams_nos;
my %nos_stream;
my @timelines;
sub stream_no
{ 
    my ($src, $sport, $dst, $dport) = @_;
    my $id = sprintf("%s:%s:%s:%s", $src, $sport, $dst, $dport);
    if ($stream_nos{$id})
    { return $stream_nos{$id}; }

    my $n = keys(%stream_nos) + 1;
#    printf("new stream: %02i: $id\n", $n);
    $stream_nos{$id} = $n;
    $nos_stream{$n} = $id;
    my @empty;
    $timelines[$n] = \@empty;

    # add reverse direction as well.
    stream_no($dst, $dport, $src, $sport);
    return $n;
}

my $n = @packets;
$line_head_len = $max_src + 13;  # length of "n: src:port > " part
$timescale = $timescale_ms / 1000;
if ($columns)
{
    my $avail = $columns - $line_head_len - 1;
    $timescale = ($maxtime - $mintime) / $avail if ($avail > 5);
}

printf("%i Packets, %ss Total. Timescale: %ims.\n\n", 
       $n, format_float($maxtime - $mintime), $timescale * 1000);

# Fill in timeline data
for (my $i = 0; $i < @packets; $i++)
{
    my ($timestamp, $src, $sport, $dst, $dport, $flags, $len) = @{$packets[$i]};
    my $slot = int(($timestamp - $mintime) / $timescale);

    my $n = stream_no($src, $sport, $dst, $dport);
    my $timeline = $timelines[$n];

    if ($flags =~ m|S|)  # SYN Flag
    {	$timeline->[$slot] = ($timeline->[$slot] eq "]" ? "I" : "[");    }

    if ($flags =~ m|F|)  # FIN Flag
    {	$timeline->[$slot] = ($timeline->[$slot] eq "[" ? "O" : "]");    }

    # Packet with data
    if ($len > 0 && 
	(!$timeline->[$slot] || $timeline->[$slot] eq "_"))
    {	$timeline->[$slot] = "#";    }

    # Anything else
    $timeline->[$slot] = "_" if ($show_empty && !$timeline->[$slot]);
}

################################################################################
# Output

if (!$no_colors)
{
    %color = ( "wb" => "\033[40;37;1m",  # white bold
	       "rb" => "\033[40;31;1m",  # red bold
	       "yb" => "\033[40;33;1m",  # yellow bold
	       "pb" => "\033[40;35;1m",  # purple bold
	       "bb" => "\033[40;34;1m",  # blue bold
	       "cb" => "\033[40;36;1m",  # cyan bold
	       "e" => "\033[0m");
}

sub format_float
{
    my ($v) = @_;
    $v = sprintf("%.3f", $v) if (length($v - int($v)) > 5);
    return $v;
}

# Print scale
my $str = "";
my $nslots = int(($maxtime - $mintime) / $timescale);
for (my $i = 0; $i < $nslots; $i += $scaleint)
{
    my $v = format_float($i * $timescale);
    $str .= sprintf("%-*s", $scaleint, $v . "s");
}
printf("%*s%s\n", $line_head_len, "Time: ", $str);

$hostname = `hostname`;  chomp($hostname);
for (my $j = 1; $j < @timelines; $j++)
{
#    printf("stream %02i: ", $j);
    my $stream = $nos_stream{$j};
    my ($src, $sport) = split(/:/, $stream);

    # Coloring
    $col_begin = $color{"yb"};
    $col_end = $color{"e"};
    if ($stream =~ m|localhost| ||
	$stream =~ m|127\.0\.0\.1|)
    {
	$col_begin = $color{"bb"};
	$col_end = $color{"e"};
    }

    $src = "" if (!$show_localhost_src && 
		  ($src eq "$hostname" ||
		   $src eq "localhost" ||
		   $src eq "127.0.0.1"));

    if (($j % 2) == 1)
    { printf("%s%02i: %*s:%-5s > ", $col_begin, ($j+1)/2, $max_src, $src, $sport); }
    else # Reverse direction
    { printf(  "%s    %*s:%-5s < ", $col_begin,           $max_src, $src, $sport); }

    my @timeline = @{$timelines[$j]};
    my $str = "";
    my $seen_something = 0;
    for (my $i = 0; $i < @timeline; $i++)
    {
	if ($timeline[$i])
	{
	    $seen_something = 1;
	    $str .= $timeline[$i];
	    next;
	}
	$str .= ($seen_something ? "." : " ");
    }
    print "$str$col_end\n";
    print "\n" if (!($j % 2));
}

