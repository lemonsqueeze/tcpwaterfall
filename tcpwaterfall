#!/usr/bin/perl

# Interval in seconds (= 1 char on screen)
my $interval = .1;

# Time scale spacing (characters)
my $scaleint = 10;

my $mintime = -1;
my $maxtime = 0;
my @packets;

# Parse output from tcpdump -tt -s 500 -l -i any
foreach my $str (<STDIN>)
{
# 1335080288.483710 IP 192.168.1.102.59415 > 69.164.192.221.80: Flags [S], seq 4016928255, win 5840, options [mss 1460,sackOK,TS val 40991055 ecr 0], length 0    
    if ($str =~ m|(.*) IP (.*)\.([^.]*) > (.*)\.([^.]*): Flags \[(.*)\], seq .*, win .*, options \[.*\], length (.*)|)
    {
	my @tab = ($1, $2, $3, $4, $5, $6, $7);
	my ($timestamp, $src, $sport, $dst, $dport, $flags, $len) = @tab;
#	print ".";

	$mintime = $timestamp if ($mintime eq -1);
	$maxtime = $timestamp;

	push(@packets, \@tab);
	#@{$packets[@packets]} = @tab;
    }
}
#print "\n";

my %streams_nos;
my %nos_stream;
my @timelines;
sub stream_no
{ 
    my ($src, $sport, $dst, $dport) = @_;
    my $id = sprintf("%s:%s:%s:%s", $src, $sport, $dst, $dport);

    if ($stream_nos{$id})
    { return $stream_nos{$id}; }
    my $n = keys(%stream_nos) + 1;
#    printf("new stream: %02i: $id\n", $n);
    $stream_nos{$id} = $n;
    $nos_stream{$n} = $id;
    my @empty;
    $timelines[$n] = \@empty;

    # add reverse direction as well.
    stream_no($dst, $dport, $src, $sport);
    return $n;
}

my $n = @packets;
printf("packets: %i\n", $n);

# Fill in timeline data
for (my $i = 0; $i < @packets; $i++)
{
    my ($timestamp, $src, $sport, $dst, $dport, $flags, $len) = @{$packets[$i]};
    my $slot = int(($timestamp - $mintime) / $interval);

    my $n = stream_no($src, $sport, $dst, $dport);
    my $timeline = $timelines[$n];

    # Syn + Fin
    $timeline->[$slot] = "O" if ($timeline->[$slot] eq "[" && $flags =~ m|F|);
    # Fin + Syn
    $timeline->[$slot] = "I" if ($timeline->[$slot] eq "]" && $flags =~ m|S|);
    if (!$timeline->[$slot])
    {
	# Syn
	$timeline->[$slot] = "[" if ($flags =~ m|S|);
	# Fin
	$timeline->[$slot] = "]" if ($flags =~ m|F|);
	# Anything else
	$timeline->[$slot] = "#" if (!$timeline->[$slot]);
    }

#    print "$timestamp $slot $n\n";
}

################################################################################
# Output

%color = ( "wb" => "\033[40;37;1m",  # white bold
           "rb" => "\033[40;31;1m",  # red bold
           "yb" => "\033[40;33;1m",  # yellow bold
           "pb" => "\033[40;35;1m",  # purple bold
           "bb" => "\033[40;34;1m",  # blue bold
           "cb" => "\033[40;36;1m",  # cyan bold
           "e" => "\033[0m");

# Formatting: Find longest src
my $max_src = 0;
for (my $j = 1; $j < @timelines; $j++)
{
    my $stream = $nos_stream{$j};
    my ($src) = split(/:/, $stream);
    $max_src = length($src) if (length($src) > $max_src);
}

# Print scale
my $str = "";
my $nslots = int(($maxtime - $mintime) / $interval);
for (my $i = 0; $i < $nslots; $i += $scaleint)
{
    $str .= sprintf("%-*s", $scaleint, ($i * $interval) . "s");
}
printf("%*s: %s\n", $max_src + 11, "Time", $str);


for (my $j = 1; $j < @timelines; $j++)
{
#    printf("stream %02i: ", $j);
    my $stream = $nos_stream{$j};
    my ($src, $sport) = split(/:/, $stream);

    # Coloring
    $col_begin = $color{"yb"};
    $col_end = $color{"e"};
    if ($stream =~ m|localhost| ||
	$stream =~ m|127\.0\.0\.1|)
    {
	$col_begin = $color{"bb"};
	$col_end = $color{"e"};
    }

    if (($j % 2) == 1)
    { printf("%s%02i: %*s:%-5s > ", $col_begin, ($j+1)/2, $max_src, $src, $sport); }
    else # Reverse direction
    { printf(  "%s    %*s:%-5s < ", $col_begin,           $max_src, $src, $sport); }

    my @timeline = @{$timelines[$j]};
    my $str = "";
    my $seen_something = 0;
    for (my $i = 0; $i < @timeline; $i++)
    {
	if ($timeline[$i])
	{
	    $seen_something = 1;
	    $str .= $timeline[$i];
	    next;
	}
	$str .= ($seen_something ? "." : " ");
    }
    print "$str$col_end\n";
    print "\n" if (!($j % 2));
}

